================================================================================
PRODUCT REQUIREMENTS DOCUMENT (PRD)
Minhas Compras - Versão 4.0
================================================================================

DOCUMENTO: PRD v2.0
DATA: Janeiro 2025
VERSÃO DO PRODUTO: 4.0
STATUS: Em Planejamento

================================================================================
1. OVERVIEW
================================================================================

PRODUTO: Minhas Compras
TIPO: Aplicativo Android para Gerenciamento de Lista de Compras
PLATAFORMA: Android 7.0+ (API 24+)
TECNOLOGIA: Kotlin, Jetpack Compose, Room Database

DESCRIÇÃO:
Minhas Compras é um aplicativo Android moderno e intuitivo para gerenciar
listas de compras pessoais. A versão 4.0 expande significativamente as
funcionalidades do app, adicionando suporte a múltiplas listas, widget na
tela inicial, estatísticas avançadas, notificações inteligentes e outras
melhorias que transformam o app em uma solução completa e profissional.

PROBLEMA QUE RESOLVE:
- Organização de compras em diferentes contextos (supermercado, farmácia, etc.)
- Acesso rápido às listas sem abrir o app
- Controle financeiro e análise de gastos
- Lembretes e notificações para não esquecer compras
- Facilidade na adição de itens com autocompletar e scanner

PÚBLICO-ALVO:
- Pessoas que fazem compras regularmente
- Usuários que precisam organizar múltiplas listas de compras
- Pessoas que querem controlar gastos e orçamento
- Famílias que compartilham listas de compras
- Usuários de smartphones Android (18-65 anos)

VALOR DO PRODUTO:
- Organização completa de compras em múltiplos contextos
- Acesso rápido via widget
- Insights financeiros através de estatísticas
- Experiência moderna com scanner e autocompletar
- Base sólida para funcionalidades colaborativas futuras

================================================================================
2. STATUS ATUAL DO PRODUTO (v3.0 - COMPLETO)
================================================================================

FUNCIONALIDADES JÁ IMPLEMENTADAS:
✓ Adicionar/editar/deletar itens com nome, quantidade, preço e categoria
✓ Marcar itens como comprado/pendente
✓ Busca em tempo real por nome
✓ Filtros: Todos, Pendentes, Comprados
✓ Ordenação por Nome, Data ou Preço
✓ Sistema de categorias (9 categorias pré-definidas)
✓ Modo escuro/claro com persistência
✓ Gestos de swipe (marcar comprado/deletar)
✓ Desfazer exclusão com Snackbar
✓ Backup e restauração (JSON)
✓ Histórico de compras com reutilização
✓ Estatísticas básicas (total, pendentes, comprados, valores)
✓ Barra de progresso visual
✓ Interface Material Design 3
✓ Sistema de atualizações OTA

ARQUITETURA ATUAL:
✓ MVVM com ViewModel
✓ Room Database com DAO e migrações
✓ Repository Pattern
✓ Kotlin Coroutines e StateFlow
✓ Jetpack Compose
✓ DataStore para preferências
✓ Sistema de notificações para atualizações

================================================================================
3. CORE FEATURES - VERSÃO 4.0
================================================================================

-------------------------------------------------------------------------------
RF-010: MÚLTIPLAS LISTAS
-------------------------------------------------------------------------------

Prioridade: ALTA
Complexidade: MÉDIA-ALTA
Estimativa: 3-4 dias (24-32 horas)
Impacto: ALTO

Descrição:
Implementar sistema completo de múltiplas listas separadas, permitindo que
usuários organizem suas compras por contexto (supermercado, farmácia, loja, etc.).

Por que é importante:
- Permite organização por contexto de compra
- Aumenta significativamente a utilidade do app
- Base fundamental para recursos futuros (compartilhamento, colaboração)
- Melhora a experiência do usuário com múltiplas necessidades

Como funciona:
- Usuário pode criar múltiplas listas nomeadas
- Cada lista é independente com seus próprios itens
- Navegação entre listas via drawer ou bottom sheet
- Lista padrão "Minhas Compras" criada automaticamente
- Gerenciamento completo: criar, renomear, deletar listas

Requisitos Funcionais:
- RF-010.1: Criar nova entidade ShoppingList no Room Database
- RF-010.2: Adicionar campo listId ao ItemCompra (relacionamento)
- RF-010.3: Criar migração do Room Database (versão atual → nova)
- RF-010.4: Lista padrão "Minhas Compras" deve ser criada automaticamente
- RF-010.5: Tela de seleção/navegação entre listas (drawer ou bottom sheet)
- RF-010.6: Dialog para criar nova lista com nome customizado
- RF-010.7: Dialog para renomear lista existente
- RF-010.8: Dialog de confirmação para deletar lista (com todos os itens)
- RF-010.9: Indicador visual da lista ativa na UI
- RF-010.10: Persistir lista ativa selecionada entre sessões
- RF-010.11: Todas as funcionalidades existentes devem funcionar por lista
- RF-010.12: Histórico deve ser associado à lista específica

Critérios de Aceitação:
- CA-010.1: Usuário pode criar múltiplas listas independentes
- CA-010.2: Navegação entre listas é intuitiva e rápida
- CA-010.3: Dados existentes são migrados para lista padrão
- CA-010.4: Deletar lista remove todos os itens associados
- CA-010.5: Performance mantida com 10+ listas
- CA-010.6: UI é clara e mostra qual lista está ativa

User Stories:
- Como usuário, eu quero criar listas separadas para supermercado e farmácia
- Como usuário, eu quero navegar facilmente entre minhas listas
- Como usuário, eu quero renomear minhas listas para melhor organização
- Como usuário, eu quero deletar listas que não uso mais

Considerações Técnicas:
- Migração do Room Database deve preservar todos os dados existentes
- Adicionar índice em listId no ItemCompra para performance
- ViewModel deve gerenciar lista ativa e operações por lista
- Repository deve filtrar queries por listId

-------------------------------------------------------------------------------

RF-011: WIDGET NA TELA INICIAL
-------------------------------------------------------------------------------

Prioridade: MÉDIA
Complexidade: MÉDIA
Estimativa: 2-3 dias (16-24 horas)
Impacto: MÉDIO-ALTO

Descrição:
Implementar widget Android na tela inicial que permite acesso rápido às
funcionalidades principais sem abrir o app.

Por que é importante:
- Melhora significativamente a experiência do usuário
- Aumenta engajamento e frequência de uso
- Acesso rápido sem abrir o app
- Diferencial competitivo importante

Como funciona:
- Widget exibe lista ativa com itens pendentes
- Mostra progresso (itens comprados/total)
- Botão para adicionar item rapidamente
- Atualização em tempo real quando app modifica dados
- Tocar no widget abre o app na lista correspondente

Requisitos Funcionais:
- RF-011.1: Criar AppWidgetProvider para widget
- RF-011.2: Layout do widget com lista de itens pendentes (scrollável)
- RF-011.3: Exibir contador de progresso (X/Y itens comprados)
- RF-011.4: Botão "Adicionar Item" que abre dialog no app
- RF-011.5: Atualização automática quando dados mudam (AppWidgetManager.updateAppWidget)
- RF-011.6: Suporte a múltiplos widgets (um por lista)
- RF-011.7: Configuração de qual lista o widget exibe
- RF-011.8: Tocar em item do widget marca como comprado
- RF-011.9: Widget deve funcionar em modo claro e escuro
- RF-011.10: Tamanhos: pequeno (2x1), médio (4x2), grande (4x4)

Critérios de Aceitação:
- CA-011.1: Widget exibe dados corretos da lista selecionada
- CA-011.2: Atualização acontece automaticamente quando app modifica dados
- CA-011.3: Adicionar item via widget funciona corretamente
- CA-011.4: Marcar item como comprado via widget atualiza widget e app
- CA-011.5: Widget é responsivo e não trava a tela inicial
- CA-011.6: Funciona corretamente em diferentes tamanhos de tela

User Stories:
- Como usuário, eu quero ver minha lista na tela inicial sem abrir o app
- Como usuário, eu quero adicionar itens rapidamente pelo widget
- Como usuário, eu quero marcar itens como comprados direto do widget
- Como usuário, eu quero ver o progresso da minha lista no widget

Considerações Técnicas:
- Usar RemoteViews para layout do widget
- BroadcastReceiver para atualizações automáticas
- WorkManager ou AlarmManager para atualizações periódicas (opcional)
- ProviderInfo para configuração do widget
- Considerar limitações de atualização do Android (throttling)

-------------------------------------------------------------------------------

RF-012: ESTATÍSTICAS AVANÇADAS
-------------------------------------------------------------------------------

Prioridade: MÉDIA
Complexidade: MÉDIA
Estimativa: 3-4 dias (24-32 horas)
Impacto: MÉDIO

Descrição:
Implementar sistema completo de estatísticas e análises com gráficos,
histórico por período e insights sobre padrões de compra.

Por que é importante:
- Ajuda no controle financeiro pessoal
- Visualização clara de padrões de compra
- Valor agregado significativo para o usuário
- Diferencia o app da concorrência

Como funciona:
- Tela dedicada de estatísticas acessível do menu
- Gráficos de gastos por período (semana/mês/ano)
- Histórico de compras filtrado por período
- Lista de itens mais comprados
- Tendências e comparações entre períodos
- Filtros por lista específica ou todas as listas

Requisitos Funcionais:
- RF-012.1: Nova tela StatisticsScreen acessível do menu
- RF-012.2: Gráfico de linha mostrando gastos ao longo do tempo
- RF-012.3: Gráfico de pizza por categoria de gastos
- RF-012.4: Gráfico de barras comparando períodos
- RF-012.5: Filtros de período: Semana, Mês, 3 Meses, Ano, Personalizado
- RF-012.6: Lista de itens mais comprados (top 10-20)
- RF-012.7: Estatísticas de frequência (quantas vezes item foi comprado)
- RF-012.8: Comparação de gastos entre períodos (aumento/diminuição %)
- RF-012.9: Média de gastos por período
- RF-012.10: Exportar estatísticas como imagem ou PDF (opcional)
- RF-012.11: Filtro por lista específica ou todas as listas

Critérios de Aceitação:
- CA-012.1: Gráficos são renderizados corretamente e responsivos
- CA-012.2: Dados são calculados corretamente do histórico
- CA-012.3: Performance aceitável mesmo com muito histórico
- CA-012.4: UI é intuitiva e fácil de entender
- CA-012.5: Filtros funcionam corretamente e atualizam gráficos
- CA-012.6: Itens mais comprados são calculados corretamente

User Stories:
- Como usuário, eu quero ver meus gastos ao longo do tempo em um gráfico
- Como usuário, eu quero saber quais categorias gasto mais
- Como usuário, eu quero ver quais itens compro com mais frequência
- Como usuário, eu quero comparar meus gastos entre meses diferentes

Considerações Técnicas:
- Usar biblioteca de gráficos (MPAndroidChart ou similar)
- Agregar dados do histórico de compras
- Cache de cálculos para performance
- Lazy loading para grandes volumes de dados
- Considerar uso de Room para queries agregadas

-------------------------------------------------------------------------------

RF-013: NOTIFICAÇÕES INTELIGENTES
-------------------------------------------------------------------------------

Prioridade: MÉDIA
Complexidade: BAIXA-MÉDIA
Estimativa: 2 dias (16 horas)
Impacto: MÉDIO

Descrição:
Implementar sistema de notificações que ajuda usuários a não esquecer
suas compras e mantém engajamento.

Por que é importante:
- Aumenta engajamento do usuário
- Ajuda a não esquecer compras importantes
- Melhora experiência do usuário
- Funcionalidade esperada em apps modernos

Como funciona:
- Lembrete configurável para ir às compras (dia/hora)
- Notificação quando lista estiver completa
- Lembretes de itens pendentes há muito tempo (ex: 7 dias)
- Notificações baseadas em localização (opcional - futuro)
- Configurações na tela de Settings

Requisitos Funcionais:
- RF-013.1: Sistema de notificações usando NotificationManager
- RF-013.2: Canal de notificações configurado (Android 8.0+)
- RF-013.3: Lembrete diário configurável (horário personalizado)
- RF-013.4: Notificação quando todos os itens forem marcados como comprados
- RF-013.5: Lembrete de itens pendentes há X dias (configurável, padrão 7)
- RF-013.6: Tela de configurações de notificações em SettingsScreen
- RF-013.7: Toggle para habilitar/desabilitar cada tipo de notificação
- RF-013.8: WorkManager para agendar notificações recorrentes
- RF-013.9: Notificação com ação rápida "Abrir App"
- RF-013.10: (Opcional) Notificação baseada em geofencing (localização)

Critérios de Aceitação:
- CA-013.1: Notificações são exibidas no horário configurado
- CA-013.2: Usuário pode habilitar/desabilitar cada tipo
- CA-013.3: Notificações não são excessivas ou intrusivas
- CA-013.4: Ações rápidas funcionam corretamente
- CA-013.5: Notificações persistem após reiniciar dispositivo
- CA-013.6: Respeita configurações de "Não Perturbe" do sistema

User Stories:
- Como usuário, eu quero receber um lembrete diário para fazer compras
- Como usuário, eu quero ser notificado quando minha lista estiver completa
- Como usuário, eu quero ser lembrado de itens que estão pendentes há muito tempo
- Como usuário, eu quero controlar quais notificações recebo

Considerações Técnicas:
- Usar WorkManager para notificações agendadas
- NotificationChannel para Android 8.0+
- Considerar Battery Optimization do Android
- Persistir preferências de notificação no DataStore
- Implementar cancelamento de notificações quando necessário

-------------------------------------------------------------------------------

RF-014: MELHORIAS NO DIALOG (AUTOCOMPLETAR)
-------------------------------------------------------------------------------

Prioridade: BAIXA-MÉDIA
Complexidade: BAIXA
Estimativa: 1 dia (8 horas)
Impacto: BAIXO-MÉDIO

Descrição:
Melhorar o dialog de adicionar/editar itens com autocompletar inteligente
e sugestões baseadas em histórico.

Por que é importante:
- Acelera significativamente a entrada de dados
- Melhora experiência do usuário
- Reduz erros de digitação
- Funcionalidade esperada em apps modernos

Como funciona:
- Campo de nome com autocompletar baseado em itens anteriores
- Sugestões de itens mais frequentes no topo
- Validação melhorada com feedback visual
- Sugestões de preço baseadas em compras anteriores do mesmo item

Requisitos Funcionais:
- RF-014.1: Autocompletar no campo "Nome" usando itens do histórico
- RF-014.2: Sugestões ordenadas por frequência (itens mais comprados primeiro)
- RF-014.3: Sugestão de preço baseada na última compra do item
- RF-014.4: Sugestão de quantidade baseada na última compra
- RF-014.5: Sugestão de categoria baseada no item mais similar
- RF-014.6: Validação em tempo real com feedback visual
- RF-014.7: Mensagens de erro claras e específicas
- RF-014.8: Indicador visual de campos obrigatórios
- RF-014.9: Botão "Limpar" para resetar formulário

Critérios de Aceitação:
- CA-014.1: Autocompletar sugere itens relevantes enquanto usuário digita
- CA-014.2: Sugestões são ordenadas por relevância (frequência)
- CA-014.3: Validação previne submissão de dados inválidos
- CA-014.4: Feedback de erros é claro e ajuda o usuário
- CA-014.5: Performance é mantida mesmo com muitos itens no histórico

User Stories:
- Como usuário, eu quero que o app sugira nomes de itens que já adicionei
- Como usuário, eu quero ver itens que adiciono frequentemente primeiro
- Como usuário, eu quero que o app sugira preço e quantidade baseado em compras anteriores
- Como usuário, eu quero ser avisado se cometer um erro ao preencher campos

Considerações Técnicas:
- Usar AutocompleteTextField do Material 3
- Query no histórico para buscar itens similares
- Cache de sugestões frequentes para performance
- Algoritmo de similaridade de strings (fuzzy matching)
- Debounce na busca de sugestões

-------------------------------------------------------------------------------

RF-015: SCANNER DE CÓDIGO DE BARRAS
-------------------------------------------------------------------------------

Prioridade: BAIXA
Complexidade: ALTA
Estimativa: 4-5 dias (32-40 horas)
Impacto: MÉDIO

Descrição:
Implementar funcionalidade de scanner de código de barras para adicionar
itens rapidamente escaneando produtos.

Por que é importante:
- Diferencial competitivo significativo
- Facilita muito a adição de itens
- Experiência moderna e intuitiva
- Reduz erros de digitação

Como funciona:
- Botão de scanner no dialog de adicionar item
- Abre câmera para escanear código de barras
- Busca informações do produto via API
- Preenche automaticamente nome, categoria e preço sugerido
- Permite edição antes de salvar

Requisitos Funcionais:
- RF-015.1: Integração com biblioteca de leitura de código de barras (ML Kit ou ZXing)
- RF-015.2: Botão de scanner no dialog de adicionar item
- RF-015.3: Tela de scanner com preview da câmera
- RF-015.4: Feedback visual quando código é detectado
- RF-015.5: Integração com API de produtos (OpenFoodFacts ou similar)
- RF-015.6: Buscar nome, categoria e informações do produto
- RF-015.7: Preencher campos do dialog automaticamente
- RF-015.8: Permitir edição manual após escanear
- RF-015.9: Tratamento de produtos não encontrados
- RF-015.10: Suporte a múltiplos formatos (EAN-13, UPC, etc.)
- RF-015.11: Permissões de câmera solicitadas adequadamente
- RF-015.12: Modo offline com cache de produtos escaneados

Critérios de Aceitação:
- CA-015.1: Scanner detecta códigos de barras corretamente
- CA-015.2: Informações do produto são buscadas e preenchidas
- CA-015.3: Funciona em diferentes condições de iluminação
- CA-015.4: Tratamento adequado de produtos não encontrados
- CA-015.5: Performance aceitável (detecção em < 2 segundos)
- CA-015.6: Permissões são solicitadas de forma clara

User Stories:
- Como usuário, eu quero escanear código de barras para adicionar itens rapidamente
- Como usuário, eu quero que o app busque informações do produto automaticamente
- Como usuário, eu quero poder editar informações após escanear
- Como usuário, eu quero que funcione mesmo sem internet (com cache)

Considerações Técnicas:
- Usar ML Kit Barcode Scanning (Google) ou ZXing
- Integração com OpenFoodFacts API (gratuita)
- Cache local de produtos escaneados
- Tratamento de erros de rede e produtos não encontrados
- Permissões de câmera (AndroidManifest e runtime)
- Considerar uso de câmera em background thread
- Testar em diferentes dispositivos e condições

Desafios:
- Requer biblioteca externa de leitura
- Integração com APIs de produtos
- Tratamento robusto de produtos não encontrados
- Performance em diferentes condições de iluminação

-------------------------------------------------------------------------------

RF-016: COMPARTILHAMENTO COLABORATIVO
-------------------------------------------------------------------------------

Prioridade: BAIXA
Complexidade: ALTA
Estimativa: 1-2 semanas (80-100 horas)
Impacto: ALTO (mas complexo)

Descrição:
Implementar sistema completo de compartilhamento e edição colaborativa
de listas em tempo real usando Supabase como backend.

Por que é importante:
- Funcionalidade avançada muito valorizada
- Aumenta significativamente o valor do produto
- Base para recursos sociais futuros
- Diferencial competitivo importante

Como funciona:
- Usuário pode compartilhar lista com outros usuários
- Múltiplos usuários podem editar a mesma lista simultaneamente
- Sincronização em tempo real via Supabase Realtime
- Sistema de autenticação de usuários
- Notificações quando outros usuários fazem alterações

Requisitos Funcionais:
- RF-016.1: Sistema de autenticação (email/senha ou OAuth)
- RF-016.2: Perfil de usuário com nome e foto
- RF-016.3: Compartilhar lista via link ou email
- RF-016.4: Convites para colaborar em listas
- RF-016.5: Sincronização em tempo real de alterações
- RF-016.6: Indicador visual de quem está editando (presence)
- RF-016.7: Resolução de conflitos quando múltiplos usuários editam
- RF-016.8: Histórico de alterações (quem fez o quê)
- RF-016.9: Permissões: visualizar, editar, administrador
- RF-016.10: Notificações push quando lista é modificada
- RF-016.11: Modo offline com sincronização posterior
- RF-016.12: Migração de dados locais para cloud

Critérios de Aceitação:
- CA-016.1: Múltiplos usuários podem editar simultaneamente sem conflitos
- CA-016.2: Alterações aparecem em tempo real para todos
- CA-016.3: Sincronização funciona corretamente após modo offline
- CA-016.4: Sistema de permissões funciona adequadamente
- CA-016.5: Performance aceitável mesmo com muitos colaboradores
- CA-016.6: Dados locais são migrados corretamente para cloud

User Stories:
- Como usuário, eu quero compartilhar minha lista com minha família
- Como usuário, eu quero ver alterações feitas por outros em tempo real
- Como usuário, eu quero saber quem está editando a lista
- Como usuário, eu quero poder editar mesmo sem internet (sincronizar depois)

Considerações Técnicas:
- Backend: Supabase (PostgreSQL + Realtime + Auth)
- Sincronização: Supabase Realtime subscriptions
- Resolução de conflitos: Last-Write-Wins ou Operational Transform
- Autenticação: Supabase Auth
- Notificações: Firebase Cloud Messaging ou Supabase
- Modo offline: Room local + sincronização quando online
- Migração: Script para migrar dados locais para Supabase

Desafios:
- Requer backend completo (Supabase)
- Sincronização em tempo real complexa
- Resolução de conflitos é desafiadora
- Autenticação e segurança
- Performance com muitos usuários simultâneos

================================================================================
4. USER EXPERIENCE
================================================================================

PERSONAS:

1. Maria - 35 anos, mãe de família
   - Usa o app para organizar compras da família
   - Precisa de múltiplas listas (supermercado, farmácia)
   - Valoriza widget para acesso rápido
   - Quer ver estatísticas de gastos

2. João - 28 anos, solteiro
   - Usa para compras pessoais
   - Valoriza rapidez (scanner, autocompletar)
   - Quer notificações para não esquecer
   - Interessado em compartilhar com amigos

3. Ana - 45 anos, gerente de casa
   - Organiza compras da família
   - Precisa de múltiplas listas por contexto
   - Valoriza estatísticas para controle financeiro
   - Quer compartilhar lista com marido

JORNADA DO USUÁRIO:

Fluxo Principal - Adicionar Item:
1. Usuário abre app (ou widget)
2. Vê lista atual ou seleciona outra lista
3. Clica em "Adicionar Item"
4. Dialog abre com autocompletar
5. Usuário digita ou escaneia código
6. Campos são preenchidos automaticamente
7. Usuário confirma e item é adicionado
8. Lista atualiza em tempo real

Fluxo - Múltiplas Listas:
1. Usuário abre drawer de navegação
2. Vê todas as listas disponíveis
3. Seleciona lista desejada
4. App carrega itens da lista selecionada
5. Todas as operações funcionam na lista ativa

Fluxo - Widget:
1. Usuário vê widget na tela inicial
2. Vê itens pendentes e progresso
3. Clica em item para marcar como comprado
4. Widget atualiza automaticamente
5. Ou clica em "Adicionar" para abrir dialog

Fluxo - Estatísticas:
1. Usuário abre menu e seleciona "Estatísticas"
2. Vê gráficos e análises
3. Filtra por período ou lista
4. Analisa padrões de compra
5. Exporta se necessário

UI/UX CONSIDERAÇÕES:
- Navegação intuitiva entre listas (drawer ou bottom sheet)
- Widget deve ser informativo mas não poluído
- Gráficos devem ser claros e fáceis de entender
- Notificações não devem ser intrusivas
- Scanner deve ter feedback visual claro
- Autocompletar deve ser rápido e relevante

================================================================================
5. TECHNICAL ARCHITECTURE
================================================================================

COMPONENTES DO SISTEMA:

1. Data Layer:
   - Room Database (local)
   - Supabase (cloud - para colaboração)
   - DataStore (preferências)
   - Cache de produtos escaneados

2. Business Logic Layer:
   - ViewModels por feature
   - Repository Pattern
   - Use Cases para lógica complexa
   - Sincronização de dados

3. UI Layer:
   - Jetpack Compose
   - Material Design 3
   - Navigation Component
   - Widget Provider

4. External Services:
   - ML Kit / ZXing (scanner)
   - OpenFoodFacts API (produtos)
   - Supabase (colaboração)
   - WorkManager (notificações)

MODELOS DE DADOS:

ShoppingList:
- id: Long (primary key)
- name: String
- createdAt: Long
- isDefault: Boolean
- userId: String? (para colaboração)

ItemCompra (atualizado):
- id: Long
- listId: Long (foreign key)
- nome: String
- quantidade: Int
- preco: Double?
- categoria: String
- comprado: Boolean
- createdAt: Long

ProductCache (novo):
- barcode: String (primary key)
- name: String
- category: String
- lastUpdated: Long

User (novo - para colaboração):
- id: String
- email: String
- name: String
- photoUrl: String?

APIs E INTEGRAÇÕES:

1. OpenFoodFacts API:
   - Endpoint: https://world.openfoodfacts.org/api/v0/product/{barcode}.json
   - Busca informações de produtos por código de barras
   - Retorna nome, categoria, ingredientes, etc.

2. Supabase:
   - PostgreSQL database
   - Realtime subscriptions
   - Authentication
   - Storage (para fotos de perfil)

REQUISITOS DE INFRAESTRUTURA:

- Android 7.0+ (API 24+)
- Permissões: Câmera, Internet, Notificações
- Espaço de armazenamento: Mínimo 50MB
- Conexão internet: Necessária para colaboração e scanner (opcional offline)

================================================================================
6. DEVELOPMENT ROADMAP
================================================================================

FASE 1: FUNDAÇÃO (Semanas 1-2)
Objetivo: Estabelecer base para múltiplas listas e melhorias core

MVP da Fase 1:
- RF-010: Múltiplas Listas (completo)
- RF-014: Melhorias no Dialog (autocompletar)
- Migração de dados existentes
- Testes básicos de múltiplas listas

Entregáveis:
- Sistema de múltiplas listas funcional
- Autocompletar no dialog
- Dados migrados corretamente
- App estável e testado

FASE 2: ACESSO RÁPIDO E INSIGHTS (Semanas 3-4)
Objetivo: Widget e estatísticas para melhorar experiência

MVP da Fase 2:
- RF-011: Widget na Tela Inicial
- RF-012: Estatísticas Avançadas
- Integração widget com múltiplas listas
- Gráficos funcionais

Entregáveis:
- Widget funcional e responsivo
- Tela de estatísticas completa
- Gráficos renderizando corretamente
- Performance otimizada

FASE 3: ENGAGEMENT (Semana 5)
Objetivo: Notificações para aumentar engajamento

MVP da Fase 3:
- RF-013: Notificações Inteligentes
- Configurações de notificações
- WorkManager implementado
- Testes de notificações

Entregáveis:
- Sistema de notificações completo
- Configurações funcionais
- Notificações agendadas corretamente

FASE 4: EXPERIÊNCIA MODERNA (Semanas 6-7)
Objetivo: Scanner para facilitar adição de itens

MVP da Fase 4:
- RF-015: Scanner de Código de Barras
- Integração com ML Kit
- API de produtos funcionando
- Cache de produtos

Entregáveis:
- Scanner funcional
- Busca de produtos via API
- Cache implementado
- Tratamento de erros robusto

FASE 5: COLABORAÇÃO (Semanas 8-12)
Objetivo: Compartilhamento e edição colaborativa

MVP da Fase 5:
- RF-016: Compartilhamento Colaborativo
- Autenticação Supabase
- Sincronização em tempo real
- Resolução de conflitos
- Modo offline

Entregáveis:
- Sistema de colaboração completo
- Sincronização em tempo real funcionando
- Autenticação e permissões
- App estável e testado

MELHORIAS FUTURAS (Pós v4.0):
- Notificações baseadas em localização (geofencing)
- Exportar estatísticas como PDF
- Temas personalizados
- Atalhos de teclado
- Integração com assistentes de voz
- Modo escuro automático por horário

================================================================================
7. LOGICAL DEPENDENCY CHAIN
================================================================================

ORDEM LÓGICA DE DESENVOLVIMENTO:

1. FUNDAÇÃO (Deve ser feito primeiro):
   - RF-010: Múltiplas Listas
     * Base para todas as outras features
     * Migração de dados é crítica
     * Todas as features dependem disso

2. MELHORIAS CORE (Pode ser feito em paralelo após fundação):
   - RF-014: Melhorias no Dialog
     * Independente, melhora UX imediatamente
     * Não depende de outras features

3. ACESSO RÁPIDO (Após múltiplas listas):
   - RF-011: Widget
     * Depende de múltiplas listas (precisa selecionar qual lista)
     * Pode ser desenvolvido em paralelo com estatísticas

4. INSIGHTS (Pode ser feito em paralelo):
   - RF-012: Estatísticas Avançadas
     * Depende de histórico (já existe)
     * Pode ser desenvolvido em paralelo com widget

5. ENGAGEMENT (Independente):
   - RF-013: Notificações
     * Independente das outras features
     * Pode ser feito a qualquer momento após Fase 1

6. EXPERIÊNCIA MODERNA (Independente):
   - RF-015: Scanner
     * Independente, mas melhora com autocompletar
     * Pode ser feito após Fase 1 ou 2

7. COLABORAÇÃO (Deve ser feito por último):
   - RF-016: Compartilhamento Colaborativo
     * Depende de múltiplas listas
     * Requer backend completo
     * Mais complexo, deve ser feito por último

PRIORIZAÇÃO PARA MVP RÁPIDO:

Se precisar de algo funcional rapidamente:
1. RF-010 (Múltiplas Listas) - 3-4 dias
2. RF-014 (Autocompletar) - 1 dia
3. RF-011 (Widget) - 2-3 dias
4. RF-013 (Notificações) - 2 dias

Total: ~8-10 dias para MVP funcional com alto valor

ESCOPO ATÔMICO DE CADA FEATURE:

Cada feature deve ser:
- Completa e funcional sozinha
- Testável independentemente
- Pode ser melhorada incrementalmente
- Não quebra funcionalidades existentes

EXEMPLO - Múltiplas Listas:
- Fase 1: Criar/renomear/deletar listas básico
- Fase 2: Navegação melhorada, indicadores visuais
- Fase 3: Busca de listas, filtros, ordenação

================================================================================
8. RISKS AND MITIGATIONS
================================================================================

RISCO-001: Migração de dados para múltiplas listas pode corromper dados
Probabilidade: MÉDIA
Impacto: ALTO
Mitigação:
- Criar backup completo antes da migração
- Testar migração extensivamente com dados de teste
- Implementar rollback se migração falhar
- Migração incremental com validação em cada passo

RISCO-002: Widget pode ter problemas de performance
Probabilidade: MÉDIA
Impacto: MÉDIO
Mitigação:
- Limitar número de itens exibidos no widget
- Usar atualizações eficientes (não a cada mudança)
- Testar em dispositivos de baixo desempenho
- Implementar cache de dados do widget

RISCO-003: Integração com API de produtos pode falhar
Probabilidade: ALTA
Impacto: MÉDIO
Mitigação:
- Implementar cache robusto de produtos
- Modo offline funcional
- Tratamento de erros claro para usuário
- Fallback para busca manual se API falhar

RISCO-004: Sincronização colaborativa pode ter conflitos
Probabilidade: ALTA
Impacto: ALTO
Mitigação:
- Implementar estratégia clara de resolução de conflitos
- Testar extensivamente com múltiplos usuários
- Modo offline com merge inteligente
- Logs detalhados para debug

RISCO-005: Notificações podem ser bloqueadas pelo sistema
Probabilidade: MÉDIA
Impacto: BAIXO
Mitigação:
- Educar usuário sobre permissões necessárias
- Verificar se notificações estão habilitadas
- Oferecer alternativa (lembrete no app)
- Seguir best practices do Android

RISCO-006: Complexidade do projeto pode aumentar muito
Probabilidade: ALTA
Impacto: ALTO
Mitigação:
- Priorizar features por valor/impacto
- Implementar incrementalmente
- Manter código modular e testável
- Revisar escopo regularmente

DESAFIOS TÉCNICOS:

1. MVP que podemos construir:
   - Focar em Fase 1 e 2 primeiro
   - Deixar colaboração para depois
   - Validar com usuários antes de expandir

2. Restrições de recursos:
   - Desenvolver features incrementais
   - Reutilizar código existente
   - Usar bibliotecas testadas

3. Performance:
   - Otimizar queries do Room
   - Implementar paginação onde necessário
   - Cache inteligente de dados

================================================================================
9. APPENDIX
================================================================================

PESQUISAS E REFERÊNCIAS:

Bibliotecas Recomendadas:
- ML Kit Barcode Scanning (Google) - Scanner
- MPAndroidChart - Gráficos
- Supabase Android SDK - Backend
- WorkManager - Notificações agendadas

APIs Externas:
- OpenFoodFacts: https://world.openfoodfacts.org/
- Documentação: https://openfoodfacts.github.io/api-documentation/

ESPECIFICAÇÕES TÉCNICAS:

Migração Room Database:
- Versão atual: 3
- Nova versão: 4
- Adicionar tabela ShoppingList
- Adicionar campo listId em ItemCompra
- Migrar dados existentes para lista padrão

Widget Specifications:
- Tamanhos suportados: 2x1, 4x2, 4x4
- Atualização: On-demand e periódica (máx 1x/hora)
- Limite de itens: 10-15 itens no widget pequeno

Notificações:
- Canal: "Lembretes de Compras"
- Prioridade: DEFAULT (não intrusivo)
- Som: Opcional, configurável
- Vibração: Opcional, configurável

ESTIMATIVAS DETALHADAS:

Fase 1 (Múltiplas Listas + Autocompletar):
- Múltiplas Listas: 24-32 horas
- Autocompletar: 8 horas
- Testes e polimento: 8 horas
- Total: 40-48 horas (~1-1.5 semanas)

Fase 2 (Widget + Estatísticas):
- Widget: 16-24 horas
- Estatísticas: 24-32 horas
- Integração: 8 horas
- Total: 48-64 horas (~1.5-2 semanas)

Fase 3 (Notificações):
- Implementação: 12 horas
- Configurações: 4 horas
- Testes: 4 horas
- Total: 20 horas (~3 dias)

Fase 4 (Scanner):
- Integração ML Kit: 8 horas
- UI do scanner: 8 horas
- API de produtos: 12 horas
- Cache e offline: 8 horas
- Total: 36 horas (~1 semana)

Fase 5 (Colaboração):
- Setup Supabase: 8 horas
- Autenticação: 16 horas
- Sincronização: 24 horas
- Resolução conflitos: 16 horas
- UI colaboração: 16 horas
- Testes: 16 horas
- Total: 96 horas (~2-3 semanas)

TOTAL ESTIMADO: 240-280 horas (~6-7 semanas de desenvolvimento)

================================================================================
10. CRITÉRIOS DE SUCESSO
================================================================================

FUNCIONALIDADES OBRIGATÓRIAS (MVP v4.0):
✓ Múltiplas listas funcionando completamente
✓ Widget na tela inicial funcional
✓ Estatísticas avançadas com gráficos
✓ Notificações inteligentes configuráveis
✓ Autocompletar no dialog
✓ Scanner de código de barras (opcional mas desejável)

QUALIDADE:
✓ Sem crashes críticos
✓ Performance aceitável (< 100ms para operações)
✓ UI responsiva e intuitiva
✓ Acessibilidade mantida
✓ Dados preservados em migrações

ENTREGÁVEIS:
✓ APK de Release (v4.0)
✓ Código-fonte no GitHub
✓ Release Notes detalhadas
✓ Documentação atualizada
✓ Testes implementados (cobertura mínima 40%)

MÉTRICAS DE SUCESSO:
- Taxa de retenção de usuários aumenta
- Tempo médio de adicionar item reduz em 50%
- Engajamento aumenta (medido por notificações)
- Feedback positivo de usuários sobre novas features

================================================================================
FIM DO DOCUMENTO
================================================================================
